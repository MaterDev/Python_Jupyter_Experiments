import numpy as np
import pyaudio
import threading
import atexit

def play_tone(frequency):
    """
    ‚ö†Ô∏è Experimental
    Generates and plays a continuous sine wave tone of a specified frequency.
    
    Parameters:
    - frequency (float): The frequency of the tone in Hertz (Hz).
    
    This function generates a sine wave of the specified frequency and plays it 
    continuously until the global exit_signal is set. The sound is played through 
    the default audio output device of the system.
    
    ‚ö†Ô∏è Warning:
    Listening to high-volume tones, especially through earphones, can cause 
    hearing damage or discomfort. Users should lower the volume before playing 
    the tones, and raise it cautiously to a comfortable level. Listening to 
    tones generated by this function through earphones is done at the user's own risk.
    
    Example:
    >>> play_tone(440)  # Plays a tone of 440 Hz
    """
    
    # Sampling parameters
    rate = 44100    # samples per second
    T = 1.0         # sample duration (seconds)
    t = np.linspace(0, T, int(T*rate), False)  # time variable
    y = 0.5*np.sin(2*np.pi*frequency*t)  # waveform

    p = pyaudio.PyAudio()
    stream = p.open(format=pyaudio.paFloat32,
                    channels=1,
                    rate=rate,
                    output=True)

    # Continuously play the waveform
    while not exit_signal.is_set():
        stream.write(y.astype(np.float32).tobytes())

    stream.stop_stream()
    stream.close()
    p.terminate()

def play_tones(frequencies):
    for frequency in frequencies:
        tone_thread = threading.Thread(target=play_tone, args=(frequency,))
        tone_thread.daemon = True  # Set thread as daemon
        tone_threads.append(tone_thread)
        tone_thread.start()

def stop_tones():
    exit_signal.set()

# Register the stop_tones function to be called on exit
atexit.register(stop_tones)

exit_signal = threading.Event()
tone_threads = []
frequencies = [33]  # Add up to 10 frequencies

play_tones(frequencies)

try:
    while True:  # Keep the script running
        pass
except KeyboardInterrupt:
    pass  # Exit on Ctrl + C

# ------------------------

"""
    üëâüèæ 'sounddevice' library offers more control over the buffer size and other playback parameters compared to pyaudio.
    
    In this example, the blocksize parameter is used to specify the buffer size when calling sd.play(). You can adjust the buffer_size variable to different values to see if it helps resolve the cracking and inconsistencies you're hearing.
    
    ```
    import numpy as np
    import sounddevice as sd
    import threading

    def play_tone(frequency):
        rate = 44100    # samples per second
        T = 1.0         # sample duration (seconds)
        t = np.linspace(0, T, int(T*rate), False)  # time variable
        y = 0.5*np.sin(2*np.pi*frequency*t)  # waveform

        # Use a larger buffer size to prevent buffer underruns
        buffer_size = 2048  # Adjust this value as needed

        while not exit_signal.is_set():
            sd.play(y, samplerate=rate, loop=True, blocksize=buffer_size)
            sd.wait()

    # ... rest of your code ...
    ```
"""